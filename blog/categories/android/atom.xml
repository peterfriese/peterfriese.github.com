<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Peter Friese]]></title>
  <link href="http://www.peterfriese.de/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://www.peterfriese.de/"/>
  <updated>2014-03-28T17:57:00+00:00</updated>
  <id>http://www.peterfriese.de/</id>
  <author>
    <name><![CDATA[Peter Friese]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unit Testing Android Apps with Robolectric and Eclipse]]></title>
    <link href="http://www.peterfriese.de/unit-testing-android-apps-with-robolectric-and-eclipse/"/>
    <updated>2013-11-27T09:54:00+00:00</updated>
    <id>http://www.peterfriese.de/unit-testing-android-apps-with-robolectric-and-eclipse</id>
    <content type="html"><![CDATA[<p>A few weeks ago, I showed you how to set up Robolectric with Android Studio and Gradle. For the Eclipse DemoCamp in Hamburg, I have been asked to prepare a session on how to use Robolectric with Eclipse. I thought it might be worthwhile to share my experiences with everybody who wasn&rsquo;t fortunate enough to attend the DemoCamp (in a truely stunning location, BTW), so here goes.</p>

<!-- more -->


<p>We all know testing is essential to verify the behaviour of the software you write. In the Android world with its huge variety of devices and OS versions, this is even more so. Unfortunately, the performance of the Android development environment, most notably the Android Emulator, leaves much to be desired which sometimes leads to neglicence of test discipline. Robolectric is a test framework that tries to alleviate this situation.</p>

<p>Robolectric achieves this by sitting between your code and the Android OS code intercepting calls and redirecting them to shadow objects, making it possible to run your tests inside a regular JVM. This effectively means you can run your tests on your desktop &ndash; no waiting for your code to be deployed to the Emulator or a physical device!</p>

<p>For more detailed background information about the inner workings of Roboloectric, check out <a href="http://www.slideshare.net/tylerschultz/robolectric-android-unit-testing-framework">this presentation</a> and this <a href="http://www.youtube.com/watch?v=T6FWL877txw">talk by Tyler Schultz</a>, one of the committers of Robolectric.</p>

<h2>Creating a New Project</h2>

<p>As the blog title implies, this time around, we&rsquo;ll use Eclipse to create our project under test. Make sure you&rsquo;re using the most recent version of the Eclipse ADT, which is part of the Android SDK. If you don&rsquo;t have it already, Google provides a nice all-in-one download of the SDK <a href="http://developer.android.com/sdk/index.html">here</a>.</p>

<p>Create a new project, using the following settings:</p>

<ul>
<li>Application Name: <code>RobolectricDemoProjectEclipse</code></li>
<li>Project Name: <code>RobolectricDemoProjectEclipse</code></li>
<li>Package Name: <code>de.peterfriese.robolectricdemo</code></li>
<li>Minimum SDK: <code>API 8: Android 2.2 (Froyo)</code></li>
<li>Target SDK: <code>API 18: Android 4.3</code></li>
<li>Compile With: <code>API 19: Android 4.4 (KitKat)</code></li>
</ul>


<p>Choose to create a custom icon and a custom launcher and place the project in a location of your liking.</p>

<p><ul class="gallery">
<li><a href="/images/2013-11-27-unit-testing-android-apps-with-robolectric-and-eclipse/robolectric_new_project_1.png" class="fancybox" rel="gallery-71c5a075199ab4106dd4dd708b445982" title="New Create New Project &ndash; Step 1"><img src="/thumbs/robolectric_new_project_1_200x150.png" alt="New Create New Project &ndash; Step 1" /></a></li>
<li><a href="/images/2013-11-27-unit-testing-android-apps-with-robolectric-and-eclipse/robolectric_new_project_2.png" class="fancybox" rel="gallery-71c5a075199ab4106dd4dd708b445982" title="New Create New Project &ndash; Step 2"><img src="/thumbs/robolectric_new_project_2_200x150.png" alt="New Create New Project &ndash; Step 2" /></a></li>
<li><a href="/images/2013-11-27-unit-testing-android-apps-with-robolectric-and-eclipse/robolectric_new_project_3.png" class="fancybox" rel="gallery-71c5a075199ab4106dd4dd708b445982" title="New Create New Project &ndash; Step 3"><img src="/thumbs/robolectric_new_project_3_200x150.png" alt="New Create New Project &ndash; Step 3" /></a></li>
</ul></p>

<p>On the <em>Create Activity</em> page, choose <em>Blank Activity</em>, and on the <em>Blank Activity</em> configuration page use the following settings:</p>

<ul>
<li>Activiy Name: <code>Main Actity</code></li>
<li>Layout Name: <code>activity_main</code></li>
<li>Navigation Type: <code>None</code></li>
</ul>


<p>To make things a bit more interesting, let&rsquo;s change the UI so we&rsquo;ve got a <code>TextView</code>, an <code>InputView</code> and a <code>Button</code> on, just like this:</p>

<p>```xml res/layout/fragment_main.xml</p>

<pre><code>&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin"
    tools:context=".MainActivity$PlaceholderFragment"&gt;

    &lt;TextView
        android:text="@string/hello_world"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceLarge"
        android:id="@+id/textView"
        android:layout_alignRight="@+id/editText"
        android:layout_alignParentLeft="true"/&gt;

    &lt;EditText
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/editText"
        android:layout_below="@+id/textView"
        android:layout_marginTop="24dp"
        android:layout_alignParentRight="true"
        android:layout_alignParentLeft="true"/&gt;

    &lt;Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Say Hi!"
        android:id="@+id/button"
        android:layout_below="@+id/editText"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="45dp"/&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>```</p>

<p><a href="/images/2013-11-27-unit-testing-android-apps-with-robolectric-and-eclipse/ui_layout.png" class="fancybox" title="Application Under Test UI"><img class="center" src="/thumbs/ui_layout_200x400.png" alt="Application Under Test UI" /></a></p>

<h2>Preparing for Testing</h2>

<p>To prepare your project for testing with Robolectric in Eclipse, there are a few things you need to do:</p>

<ol>
<li>Create a test project</li>
<li>Add Robolectric and its dependencies</li>
<li>Help Robolectric to find the Android manifest</li>
</ol>


<h3>Creating a Test Project</h3>

<p>The great thing about Robolectric is your tests are plain JUnit tests, so there is no need to run the tests on a device or the Emulator. This means we can use a plain Java project to host our tests.</p>

<ol>
<li>Create a new Java project, naming it <code>RobolectricDemoProjectEclipseTests</code></li>
<li>On the second page of the wizard, add a project reference to the Android project (<code>RobolectricDemoProjectEclipse</code>)</li>
</ol>


<p><ul class="gallery">
<li><a href="/images/2013-11-27-unit-testing-android-apps-with-robolectric-and-eclipse/testproject_1.png" class="fancybox" rel="gallery-8df2dbdc48dd06236a2b0a654863ff32" title="New Create New Test Project &ndash; Step 1"><img src="/thumbs/testproject_1_200x150.png" alt="New Create New Test Project &ndash; Step 1" /></a></li>
<li><a href="/images/2013-11-27-unit-testing-android-apps-with-robolectric-and-eclipse/testproject_2.png" class="fancybox" rel="gallery-8df2dbdc48dd06236a2b0a654863ff32" title="New Create New Test Project &ndash; Step 2"><img src="/thumbs/testproject_2_200x150.png" alt="New Create New Test Project &ndash; Step 2" /></a></li>
</ul></p>

<h3>Adding Robolectric and its Dependencies</h3>

<p>By now, you might be wondering why we don&rsquo;t use Maven to set up our dependencies. To cut a long story short: setting up an Android project in Eclipse is a lot easier without using Maven. The downside of this approach, however, is that we have to manage project dependencies ourselves.</p>

<p>Head over to <a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22org.robolectric%22">Maven Central</a> to fetch the <a href="http://search.maven.org/remotecontent?filepath=org/robolectric/robolectric/2.2/robolectric-2.2-jar-with-dependencies.jar">latest version of Robolectric including dependencies</a> (at the time of this writing, Robolectric 2.2 was the most up-to-date version).</p>

<p>In <code>RobolectricDemoProjectEclipseTests</code>, create a new folder <code>libs</code> and add the downloaded jar file by dragging it to the folder. After that, right-click the added file in Eclipse and choose <em>Build Path &ndash;> Add to Build Path</em> to add it to the build path.</p>

<p>Later, we will use <a href="http://square.github.io/fest-android/">FEST Android</a> to write our test assertations in a fluent way, so we need the required jar files and add the to the project as well.</p>

<ul>
<li>Latest <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&amp;g=com.squareup&amp;a=fest-android&amp;v=LATEST">FEST Android jar</a></li>
<li>Latest <a href="http://search.maven.org/remotecontent?filepath=org/easytesting/fest-assert-core/2.0M10/fest-assert-core-2.0M10.jar">FEST jar</a></li>
</ul>


<p>As JUnit is the base for all our unit tests, we need to add it to our classpath, too. Open the project&rsquo;s properties, navigate to <em>Java Build Path &ndash;> Libraries</em> and click on <em>Add Library&hellip;</em>. In the next dialog, choose <em>JUnit</em> and press <em>Next</em>. Finaly, choose <em>JUnit 4</em> (Robolectric relies on JUnit 4) and press <em>Finish</em>.</p>

<p><ul class="gallery">
<li><a href="/images/2013-11-27-unit-testing-android-apps-with-robolectric-and-eclipse/add_junit_1.png" class="fancybox" rel="gallery-a8c42e4e03479bd09d2b0e1d5e6938d2" title="Adding JUnit 4 &ndash; Step 1"><img src="/thumbs/add_junit_1_200x150.png" alt="Adding JUnit 4 &ndash; Step 1" /></a></li>
<li><a href="/images/2013-11-27-unit-testing-android-apps-with-robolectric-and-eclipse/add_junit_2.png" class="fancybox" rel="gallery-a8c42e4e03479bd09d2b0e1d5e6938d2" title="Adding JUnit 4 &ndash; Step 2"><img src="/thumbs/add_junit_2_200x150.png" alt="Adding JUnit 4 &ndash; Step 2" /></a></li>
<li><a href="/images/2013-11-27-unit-testing-android-apps-with-robolectric-and-eclipse/add_junit_3.png" class="fancybox" rel="gallery-a8c42e4e03479bd09d2b0e1d5e6938d2" title="Adding JUnit 4 &ndash; Step 3"><img src="/thumbs/add_junit_3_200x150.png" alt="Adding JUnit 4 &ndash; Step 3" /></a></li>
</ul></p>

<p>Finally, we need to add the Android library itself as a dependency to our test project. To do this, open then project properties dialog (Right-click the test project, select <em>Properties</em>) and navigate to <em>Java Build Path</em>. In the dialog, click on <em>Add External JARs&hellip;</em> and navigate to <code>&lt;Android SDK&gt;/platforms/android-19/android.jar</code> to add the latest Android jar to the projects build path.</p>

<p><ul class="gallery">
<li><a href="/images/2013-11-27-unit-testing-android-apps-with-robolectric-and-eclipse/add_android.png" class="fancybox" rel="gallery-60ff47917794e39212af739e4db0b6e3" title="Adding the Android jar"><img src="/thumbs/add_android_200x150.png" alt="Adding the Android jar" /></a></li>
</ul></p>

<h3>Helping Robolectric to Find Your Manifest</h3>

<p>Because of the way Robolectric looks for your <code>AndroidManifest.xml</code> during test startup, it won&rsquo;t find the manifest if your tests and the manifest are located in different projects.</p>

<p>Robolectric supports configuring individual tests using the <code>@Config</code> annotation, allowing you to use a different manifest file depending on the test you run. This can be quite handy, but it is a good idea to have a default configuration. Starting with version 2.0, Robolectric supports a global configuration using a config file.</p>

<p>To specifiy a manifest file, place a file named <code>org.robolectric.Config.properties</code> in the root of the <code>src</code> tree of your test project, so it can be discovered by Robolectric during test setup and add the following line:</p>

<p>```properties src/org.robolectric.Config.properties</p>

<pre><code>manifest=../RobolectricDemoProjectEclipse/AndroidManifest.xml
</code></pre>

<p>```</p>

<p>This will tell Robolectric to use the <code>AndroidManifest.xml</code> file from our Android project under test.</p>

<h2>Writing Your First Robolectric Test</h2>

<p>Let&rsquo;s write our first test! Add the following class to <code>src/test/java</code>:</p>

<p>```java MainActivityTest.java</p>

<pre><code>package de.peterfriese.robolectricdemo;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;


import static org.junit.Assert.assertTrue;

@RunWith(RobolectricTestRunner.class)
public class MainActivityTest {

    @Test
    public void shouldFail() {
        assertTrue(false);
    }
}
</code></pre>

<p>```</p>

<p>Please note that we added a simple test method, making sure it will fail. Why is this a good idea? Well, it makes sure our test fails when running it, so we can be sure the whole setup actually works. If we run the test and it <em>does not</em> fail, we know that something is wrong.</p>

<p>So, let&rsquo;s run the test! Right-click on the test file and choose <em>Run As &ndash;> JUnit Test</em>. As a result, you should see the test bar turn red in the JUnit view.</p>

<p>The test failed &ndash; just as expected. You can turn it into a passing test by changing the assert statement to <code>assertTrue(true);</code></p>

<h2>Enhancing the Test</h2>

<p>Now that we&rsquo;ve got everything in place, let&rsquo;s develop a small feature in a test-driven way. You already noted how we enhanced the UI of the application at the beginning, but apart from looking nice, there&rsquo;s not much functionality.</p>

<p>Let&rsquo;s enhance the app so the user can enter their name, press a button and be greeted by the application.</p>

<p>Make sure to statically import the Android FEST assertations &ndash; they&rsquo;ll help us to write our tests in a fluent manner:</p>

<p>``` java</p>

<pre><code>import static org.fest.assertions.api.ANDROID.assertThat;
</code></pre>

<p>```</p>

<p>As we need to have access to the app&rsquo;s main activity in all of our tests, let&rsquo;s add a private field for it and create a setup method that will create a fresh activity before each test is run:</p>

<p>```java MainActivity.java</p>

<pre><code>private MainActivity activity;

@Before
public void setup() {
    activity = Robolectric.buildActivity(MainActivity.class).get();
}
</code></pre>

<p>```</p>

<p>It is a good practice to ensure the UI is fired up and all UI elements have been initialized as expected (i.e. are not null):</p>

<p>```java MainActivityTest.java</p>

<pre><code>@Test
public void shouldNotBeNull() {
    assertThat(activity).isNotNull();

    TextView textView = (TextView) activity.findViewById(R.id.textView);
    assertThat(textView).isNotNull();

    Button button = (Button) activity.findViewById(R.id.button);
    assertThat(button).isNotNull();

    EditText editText = (EditText) activity.findViewById(R.id.editText);
    assertThat(editText).isNotNull();
}
</code></pre>

<p>```</p>

<p>Next, let&rsquo;s write a test that places a text inside the edit field, presses the button and compares the result in the text view with the expected result.</p>

<p>Here is the test method:</p>

<p>```java MainActivityTest.java</p>

<pre><code>@Test
public void shouldProduceGreetingWhenButtonPressed() {
    TextView textView = (TextView) activity.findViewById(R.id.textView);
    Button button = (Button) activity.findViewById(R.id.button);
    EditText editText = (EditText) activity.findViewById(R.id.editText);

    editText.setText("Peter");
    button.performClick();

    assertThat(textView).containsText("Hello, Peter!");
}
</code></pre>

<p>```</p>

<p>When you run the test, it will obviously fail, so let&rsquo;s fix this.</p>

<p>Open <code>MainActivity.java</code> and insert the following private class:</p>

<p>```java MainActivity.java</p>

<pre><code>public static class MainFragment extends Fragment {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Button button = (Button) this.findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                TextView textView = (TextView) MainActivity.this.findViewById(R.id.textView);
                EditText editText = (EditText) MainActivity.this.findViewById(R.id.editText);

                textView.setText(String.format("Hello, %s!", editText.getText()));
            }
        });
    }
}
</code></pre>

<p>```</p>

<p>As you can see, this code will register an <code>OnClickListener</code> for the button and set the text of the text view according to the value of the edit field.</p>

<p>The test should now pass &ndash; just run the unit test again and you should see a green bar.</p>

<h2>Conclusion</h2>

<p>Setting up an Android project for using Robolectric in Eclipse is quite a bit of work, as you just have seen, but it&rsquo;s reasonably easy with the information I have given you above. Adding Robolectric to a new Android project is just a matter of minutes with these instructions and helps you save a lot of time you&rsquo;d have had to spend otherwise running the tests on the emulator or on physical devices.</p>

<p>You might be interested in checking out my recent post on integrating Robolectric in a Gradle-based Android project in Android Studio &ndash; <a href="/android-testing-with-robolectric/">this way, please</a>.</p>

<h2>Slides and Source Code</h2>

<p>Here are the slides I used for presenting this topic at <a href="http://wiki.eclipse.org/Eclipse_DemoCamps_November_2013/Hamburg">Eclipse Democamp November 2013 in Hamburg</a>:</p>

<p><iframe src="http://www.slideshare.net/slideshow/embed_code/28679137 " width="595" height="446" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC;border-width:1px 1px 0;margin-bottom:5px" allowfullscreen></iframe> </p>

<p>The source code for this blog post can be found on <a href="https://github.com/peterfriese/RobolectricDemoProjectEclipse">Github</a> &ndash; clone and enjoy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Testing with Robolectric]]></title>
    <link href="http://www.peterfriese.de/android-testing-with-robolectric/"/>
    <updated>2013-10-23T20:02:00+01:00</updated>
    <id>http://www.peterfriese.de/android-testing-with-robolectric</id>
    <content type="html"><![CDATA[<p>We all know testing is essential to verify the behaviour of the software you write. In the Android world with its huge variety of devices and OS versions, this is even more so. Unfortunately, the performance of the Android development environment, most notably the Android Emulator, leaves much to be desired which sometimes leads to neglicence of test discipline. Robolectric is a test framework that tries to alleviate this situation.</p>

<!-- more -->


<p>Robolectric achieves this by sitting between your code and the Android OS code intercepting calls and redirecting them to shadow objects, making it possible to run your tests inside a regular JVM. This effectively means you can run your tests on your desktop &ndash; no waiting for your code to be deployed to the Emulator or a physical device!</p>

<p>For more detailed background information about the inner workings of Roboloectric, check out <a href="http://www.slideshare.net/tylerschultz/robolectric-android-unit-testing-framework">this presentation</a> and this <a href="http://www.youtube.com/watch?v=T6FWL877txw">talk by Tyler Schultz</a>, one of the committers of Robolectric.</p>

<h2>Creating a New Project</h2>

<p>To better understand how Robolectric works, let&rsquo;s create a very simple project we&rsquo;ll use as our object under test. We&rsquo;ll use Android Studio (at the time of writing, version 0.3.0 was the latest version).</p>

<p>Create a new project using the settings you can see in the following screenshots. Choose <strong>Blank Activity</strong> and <strong>Navigation Type None</strong>.</p>

<p><ul class="gallery">
<li><a href="/images/2013-10-23-android-testing-with-robolectric/new_project_1.png" class="fancybox" rel="gallery-bb45a15c1613049233feb92e00e099a8" title="New Create New Project &ndash; Step 1"><img src="/thumbs/new_project_1_200x150.png" alt="New Create New Project &ndash; Step 1" /></a></li>
<li><a href="/images/2013-10-23-android-testing-with-robolectric/new_project_2.png" class="fancybox" rel="gallery-bb45a15c1613049233feb92e00e099a8" title="New Create New Project &ndash; Step 2"><img src="/thumbs/new_project_2_200x150.png" alt="New Create New Project &ndash; Step 2" /></a></li>
<li><a href="/images/2013-10-23-android-testing-with-robolectric/new_project_3.png" class="fancybox" rel="gallery-bb45a15c1613049233feb92e00e099a8" title="New Create New Project &ndash; Step 3"><img src="/thumbs/new_project_3_200x150.png" alt="New Create New Project &ndash; Step 3" /></a></li>
</ul></p>

<p>To make things a bit more interesting, let&rsquo;s change the UI so we&rsquo;ve got a <code>TextView</code>, an <code>InputView</code> and a <code>Button</code> on, just like this:</p>

<p>```xml res/layout/fragment_main.xml</p>

<pre><code>&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    android:paddingBottom="@dimen/activity_vertical_margin"
    tools:context=".MainActivity$PlaceholderFragment"&gt;

    &lt;TextView
        android:text="@string/hello_world"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceLarge"
        android:id="@+id/textView"
        android:layout_alignRight="@+id/editText"
        android:layout_alignParentLeft="true"/&gt;

    &lt;EditText
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:id="@+id/editText"
        android:layout_below="@+id/textView"
        android:layout_marginTop="24dp"
        android:layout_alignParentRight="true"
        android:layout_alignParentLeft="true"/&gt;

    &lt;Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Say Hi!"
        android:id="@+id/button"
        android:layout_below="@+id/editText"
        android:layout_centerHorizontal="true"
        android:layout_marginTop="45dp"/&gt;

&lt;/RelativeLayout&gt;
</code></pre>

<p>```</p>

<p><a href="/images/2013-10-23-android-testing-with-robolectric/robolectric_app_ui.png" class="fancybox" title="Application Under Test UI"><img class="center" src="/thumbs/robolectric_app_ui_200x400.png" alt="Application Under Test UI" /></a></p>

<h2>Preparing for Testing</h2>

<p>To prepare your project for testing with Robolectric, there are a few things you need to do:</p>

<ol>
<li>Create a folder for your tests and make sure both Gradle and Android Studio recognize it.</li>
<li>Add the Gradle Android Test Plug-in to your project</li>
<li>Add a customized TestRunner</li>
</ol>


<h3>Creating a Folder For Your Tests</h3>

<p>When you create a new project in Android Studio, it is not yet configured for testing. If you used to develop Android apps in Eclipse, you probably are used to creating a new project for your tests. The good news is, with the new Android build system based on Gradle, you can now place your tests in the same project as your production code (refer to the <a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Testing">build system documentation</a> for more details).</p>

<p>However, Android Studio (and the Gradle Plug-in) currently expect you to place tests in <code>src/instrumentTest</code>. As we won&rsquo;t be writing instrument tests, we&rsquo;d rather like to place our tests in <code>src/test</code>. In order for this to work, we need to tell Gradle and Android Studio we&rsquo;re deviating from the default project structure:</p>

<ol>
<li>Create a new folder <code>src/test/java</code> to contain your tests.</li>
<li>Edit <code>build.gradle</code> in your project folder and add the following source set configuration to the Android plug-in configuration, right beneath the <code>defaultConfig</code> configuration:</li>
</ol>


<p>``` groovy</p>

<pre><code>    sourceSets {
        instrumentTest.setRoot('src/test')
    }
</code></pre>

<p>```</p>

<ol>
<li>Next, in Android Studio, select <code>Tools -&gt; Android -&gt; Sync Project with Gradle Files</code> from the main menu. This will tell Android Studio where to find your test files.</li>
</ol>


<p>You will notice how the icon for your test files folder turns from orange to green:</p>

<p><a href="/images/2013-10-23-android-testing-with-robolectric/robolectric_test_folder.png" class="fancybox" title="Test Folder Setup"><img class="center" src="/thumbs/robolectric_test_folder_200x150.png" alt="Test Folder Setup" /></a></p>

<h3>Adding the Gradle Test Plug-in</h3>

<p>In order to be able to run Android unit tests with Gradle, we need to add the <a href="https://github.com/JakeWharton/gradle-android-test-plugin">Gradle Android Test plug-in</a> to the build script.</p>

<ol>
<li>Add the maven snapshots repository to the build script repositories and regular repositories section. This is in order to get the fix provided in <a href="https://github.com/JakeWharton/gradle-android-test-plugin/pull/26">pull request 26</a>.
<code>groovy
     maven {
         url 'https://oss.sonatype.org/content/repositories/snapshots/'
     }
</code></li>
<li><p>Add the plug-in to the dependencies section of your <code>build.gradle</code>file:</p>

<pre><code> classpath 'com.squareup.gradle:gradle-android-test-plugin:0.9.1-SNAPSHOT'
</code></pre></li>
<li><p>Apply the plug-in:
<code>groovy
     apply plugin: 'android-test'
</code></p></li>
<li>Add test-only dependencies:
<code>groovy
     testCompile 'junit:junit:4.10'
     testCompile 'org.robolectric:robolectric:2.1.+'
     testCompile 'com.squareup:fest-android:1.0.+'
     instrumentTestCompile 'junit:junit:4.10'
     instrumentTestCompile 'org.robolectric:robolectric:2.3-SNAPSHOT'
     instrumentTestCompile 'com.squareup:fest-android:1.0.+'
</code></li>
</ol>


<p>Your <code>build.gradle</code> should now look like this:
```groovy</p>

<pre><code>buildscript {
    repositories {
        mavenCentral()
        maven {
            url 'https://oss.sonatype.org/content/repositories/snapshots/'
        }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:0.6.+'
        classpath 'com.squareup.gradle:gradle-android-test-plugin:0.9.1-SNAPSHOT'
    }
}
apply plugin: 'android'
apply plugin: 'android-test'

repositories {
    mavenCentral()
    maven {
        url 'https://oss.sonatype.org/content/repositories/snapshots/'
    }
}

android {
    compileSdkVersion 18
    buildToolsVersion "18.1.0"

    defaultConfig {
        minSdkVersion 7
        targetSdkVersion 18
    }

    sourceSets {
        instrumentTest.setRoot('src/test')
    }
}

dependencies {
    compile 'com.android.support:appcompat-v7:+'

    testCompile 'junit:junit:4.10'
    testCompile 'org.robolectric:robolectric:2.3-SNAPSHOT'
    testCompile 'com.squareup:fest-android:1.0.+'
    instrumentTestCompile 'junit:junit:4.10'
    instrumentTestCompile 'org.robolectric:robolectric:2.3-SNAPSHOT'
    instrumentTestCompile 'com.squareup:fest-android:1.0.+'

}
</code></pre>

<p>```</p>

<h3>Adding a Customized Test Runner</h3>

<p>Because of the way Robolectric looks for your <code>AndroidManifest.xml</code> during test startup, it won&rsquo;t find the manifest if your tests are located in <code>src/test/java</code>. To alleviate this situation, we need to add a custom test runner.</p>

<p>Add the following file to your project, making sure to place it somewhere in the <code>test</code> tree:</p>

<p>``` java RobolectricGradleTestRunner.java</p>

<pre><code>import android.app.Fragment;
import android.app.FragmentManager;
import android.app.FragmentTransaction;
import android.support.v4.app.FragmentActivity;

import org.junit.runners.model.InitializationError;
import org.robolectric.AndroidManifest;
import org.robolectric.Robolectric;
import org.robolectric.RobolectricTestRunner;
import org.robolectric.annotation.Config;
import org.robolectric.res.Fs;

public class RobolectricGradleTestRunner extends RobolectricTestRunner {

    public RobolectricGradleTestRunner(Class&lt;?&gt; testClass) throws InitializationError {
        super(testClass);
    }

    @Override
    protected AndroidManifest getAppManifest(Config config) {
        String manifestProperty = System.getProperty("android.manifest");
        if (config.manifest().equals(Config.DEFAULT) &amp;&amp; manifestProperty != null) {
            String resProperty = System.getProperty("android.resources");
            String assetsProperty = System.getProperty("android.assets");
            return new AndroidManifest(Fs.fileFromPath(manifestProperty), Fs.fileFromPath(resProperty),
                    Fs.fileFromPath(assetsProperty));
        }
        AndroidManifest appManifest = super.getAppManifest(config);
        return appManifest;
    }

}
</code></pre>

<p>```</p>

<h2>Writing Your First Robolectric Test</h2>

<p>Let&rsquo;s write our first test! Add the following class to <code>src/test/java</code>:</p>

<p>``` java MainActivityTest.java</p>

<pre><code>package de.peterfriese.robolectricdemo;

import org.junit.Test;
import org.junit.runner.RunWith;

import de.peterfriese.robolectric.RobolectricGradleTestRunner;

import static org.junit.Assert.assertTrue;

@RunWith(RobolectricGradleTestRunner.class)
public class MainActivityTest {

    @Test
    public void shouldFail() {
        assertTrue(false);
    }
}
</code></pre>

<p>```</p>

<p>A couple of things to note here:</p>

<p>Firstly, we use the newly created <code>RobolectricGradleTestRunner</code>to make sure the test can access the Android manifest (and thereby the other Android components in your app).</p>

<p>Secondly, we added a simple test method, making suer it will fail. Why is this a good idea? Well, it makes sure our test fails when running it, so we can be sure the whole setup actually works. If we run the test and it <em>does not</em> fail, we know that something is wrong.</p>

<p>So, let&rsquo;s run the test!
``` sh</p>

<pre><code>$ ./gradlew test

de.peterfriese.robolectricdemo.MainActivityTest &gt; shouldFail FAILED
java.lang.AssertionError at MainActivityTest.java:15

1 test completed, 1 failed
:RobolectricDemo:testDebug FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':RobolectricDemo:testDebug'.
&gt; There were failing tests. See the report at: file:///Users/peterfriese/Projects/peterfriese.de/Robolectric/RobolectricDemoProject/RobolectricDemo/build/test-report/debug/index.html

* Try:
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.

BUILD FAILED
</code></pre>

<p>```</p>

<p>So, the test failed &ndash; just as we expected. You can open the test report (<code>../RobolectricDemoProject/RobolectricDemo/build/test-report/debug/index.html</code>) in your browser to get more detailed information about the test run.</p>

<h2>Enhancing the Test</h2>

<p>Now that we&rsquo;ve got everything in place, let&rsquo;s develop a small feature in a test-driven way. You already noted how we enhanced the UI of the application at the beginning, but apart from looking nice, there&rsquo;s not much functionality.</p>

<p>Let&rsquo;s enhance the app so the user can enter their name, press a button and be greeted by the application.</p>

<p>Make sure to statically import the Android FEST assertations &ndash; they&rsquo;ll help us to write our tests in a fluent manner:</p>

<p>``` java</p>

<pre><code>import static org.fest.assertions.api.ANDROID.assertThat;
</code></pre>

<p>```</p>

<p>As we need to have access to the app&rsquo;s main activity in all of our tests, let&rsquo;s add a private field for it and create a setup method that will create a fresh activity before each test is run:</p>

<p>``` java</p>

<pre><code>private MainActivity activity;

@Before
public void setup() {
    activity = Robolectric.buildActivity(MainActivity.class).get();
}
</code></pre>

<p>```</p>

<p>It is a good practice to ensure the UI is fired up and all UI elements have been initialized as expected (i.e. are not null):</p>

<p>``` java</p>

<pre><code>@Test
public void shouldNotBeNull() {
    assertThat(activity).isNotNull();

    TextView textView = (TextView) activity.findViewById(R.id.textView);
    assertThat(textView).isNotNull();

    Button button = (Button) activity.findViewById(R.id.button);
    assertThat(button).isNotNull();

    EditText editText = (EditText) activity.findViewById(R.id.editText);
    assertThat(editText).isNotNull();
}
</code></pre>

<p>```</p>

<p>Next, let&rsquo;s write a test that places a text inside the edit field, presses the button and compares the result in the text view with the expected result.</p>

<p>Here is the test method:</p>

<p>```java</p>

<pre><code>@Test
public void shouldProduceGreetingWhenButtonPressed() {
    TextView textView = (TextView) activity.findViewById(R.id.textView);
    Button button = (Button) activity.findViewById(R.id.button);
    EditText editText = (EditText) activity.findViewById(R.id.editText);

    editText.setText("Peter");
    button.performClick();

    assertThat(textView).containsText("Hello, Peter!");
}
</code></pre>

<p>```</p>

<p>When you run the test, it will obviously fail, so let&rsquo;s fix this.</p>

<p>Open <code>MainActivity.java</code> and insert the following private class:</p>

<p>``` java MainActivity.java</p>

<pre><code>public static class MainFragment extends Fragment {
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        final View rootView = inflater.inflate(R.layout.fragment_main, container, false);
        Button button = (Button) rootView.findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                TextView textView = (TextView) rootView.findViewById(R.id.textView);
                EditText editText = (EditText) rootView.findViewById(R.id.editText);

                textView.setText(String.format("Hello, %s!", editText.getText()));
            }
        });

        return rootView;
    }
}
</code></pre>

<p>```</p>

<p>As you can see, this code will register an <code>OnClickListener</code> for the button and set the text of the text view according to the value of the edit field.</p>

<p>Also, change the constructor of <code>MainActivity</code> so it uses the new fragment class when instantiating the view fragment:</p>

<p>``` java</p>

<pre><code>    if (savedInstanceState == null) {
        getSupportFragmentManager().beginTransaction()
                .add(R.id.container, new MainFragment())
                .commit();
    }
</code></pre>

<p>```</p>

<p>The test should now pass:</p>

<p>``` sh</p>

<pre><code>$ ./gradlew test
BUILD SUCCESSFUL

Total time: 7.066 secs  
</code></pre>

<p>```</p>

<h2>Conclusion</h2>

<p>Setting up Robolectric so that you can use both Gradle and Android Studio may not be as simple as it should be, but it&rsquo;s reasonably easy with the information I have given you above. Adding Robolectric to a new Android project is just a matter of minutes with these instructions and helps you save a lot of time you&rsquo;d have had to spend otherwise running the tests on the emulator or on physical devices.</p>

<p>The source code for this blog post is <a href="https://github.com/peterfriese/RobolectricDemoProject">available on Github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Generation 2011 - Don't miss out!]]></title>
    <link href="http://www.peterfriese.de/code-generation-2011-dont-miss-out/"/>
    <updated>2011-05-21T11:09:11+01:00</updated>
    <id>http://www.peterfriese.de/code-generation-2011-dont-miss-out</id>
    <content type="html"><![CDATA[<p>Code Generation 2011 is <a href="http://www.codegeneration.net/cg2011/index.php">just around the corner</a> and if you haven&rsquo;t booked yet, <a href="http://evbk.software-acumen.com/makebooking.php?event=CG2011">you should hurry up</a> &ndash; a few places are still available!</p>

<p>Quite a number of my colleagues at itemis have been busy preparing for this conference in the past few weeks. Besides working hard to hit the <a href="http://wiki.eclipse.org/Indigo/Simultaneous_Release_Plan">Eclipse Release Train milestone for Indigo on June 22nd</a>, the Xtext team brushed up their hands-on sessions &ldquo;<a href="http://www.codegeneration.net/cg2011/sessioninfo.php?session=17">Xtext Take I: Creating Code Generators with Xtend2</a>&rdquo; and &ldquo;<a href="http://www.codegeneration.net/cg2011/sessioninfo.php?session=16">Xtext Take II: Crafting Domain Specific Languages with Xtext and Xbase</a>&rdquo;. If you&rsquo;ve been using Xtext, you&rsquo;re well aware of the power you have at your disposal with this tool. Xbase and Xtend2, however, take this experience to a whole new level. So make sure to mark your calendar for these two sessions!</p>

<!-- more -->


<p>But not only the Xtext team will share their expertise at CG2011 &ndash; Markus and Karsten will be also be in town to give hands-on tutorials and report from their experience:</p>

<ul>
<li><a href="http://www.codegeneration.net/cg2011/sessioninfo.php?session=22">Type Systems for DSLs (Markus Völter)</a></li>
<li><a href="http://www.codegeneration.net/cg2011/sessioninfo.php?session=8">Graphiti + Xtext: mixing graphical and textual DSLs for sprayers/designers (Karsten Thoms / Bernhard Merkle)</a></li>
<li><a href="http://www.codegeneration.net/cg2011/sessioninfo.php?session=5">Introduction to JetBrains Meta Programming System (MPS) (Markus Völter)</a></li>
</ul>


<p>The finale of the conference will be a panel discussion hosted by Markus on the topic of &ldquo;<a href="http://www.codegeneration.net/cg2011/sessioninfo.php?session=20">Models, DSLs, Transformations: The Next 5 years</a>&rdquo; &ndash; this should be a very interesting and lively discussion!</p>

<p><a href="http://lanyrd.com/people/hbehrens/">Heiko</a> <a href="http://lanyrd.com/people/peterfriese/">and I</a> will present &ldquo;<a href="http://www.codegeneration.net/cg2011/sessioninfo.php?session=28">Cross-Platform Mobile Development with DSLs</a>&rdquo; &ndash; a <a href="http://lanyrd.com/2011/cg2011/sdpgm/">fast-paced and fun mixture of slides, live coding (or modeling, if you will), videos and audience interaction</a>. Yes, that&rsquo;s right &ndash; the audience will be part of the show. Make sure to bring your web-enabled mobile phone and get the chance to win a price!</p>

<p>To keep track of the conference program(me), we at <a href="http://mobile.itemis.com">itemis mobile</a> have been busy to create a conference planner for your iOS and Android powered mobile phones. Here are the download links:</p>

<ul>
<li>Apple App Store: <a href="http://itunes.apple.com/us/app/code-generation-2011/id436689925?mt=8">Code Generation 2011</a></li>
<li>Android Market Place: <a href="https://market.android.com/details?id=de.itemis.mobile.android.cg2011&amp;feature=search_result">Code Generation 2011</a></li>
</ul>


<p><ul class="gallery">
<li><a href="/images/2011-05-21-code-generation-2011-dont-miss-out/cg2011.png" class="fancybox" rel="gallery-f9049cdceaffaf2ba66743d40d991d29" title="Code Generation 2011 Apps for iPhone and Android"><img src="/thumbs/cg2011_300x300.png" alt="Code Generation 2011 Apps for iPhone and Android" /></a></li>
</ul></p>

<p>If you like the apps, please use the feedback feature of the respective store. Got comments or suggestions for improvement? <a href="mailto:mobile@itemis.de">Drop us a note</a> or track us down at the conference (best chance to see us: <a href="http://www.codegeneration.net/cg2011/sessioninfo.php?session=28">come to our talk</a> ;&ndash;) ).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Save a Tree, Put EclipseCon 2011 in Your Pocket]]></title>
    <link href="http://www.peterfriese.de/save-a-tree-put-eclipsecon-2011-in-your-pocket/"/>
    <updated>2011-02-25T22:15:57+00:00</updated>
    <id>http://www.peterfriese.de/save-a-tree-put-eclipsecon-2011-in-your-pocket</id>
    <content type="html"><![CDATA[<p>After the huge success of the mobile apps for Eclipse Summit Europe, we decided to provide mobile apps for EclipseCon 2011, too. So instead of using a printed copy of the conference program, you can browse the schedule on your smart phone &ndash; wherever you are!</p>

<!-- more -->


<p>This year, we&rsquo;re providing a rather impressive lineup of mobile apps for iPhone, iPod Touch, iPad (thanks to <a href="http://www.compeople.eu/blog/?p=786">Christian Campo who created a stand-alone iPad app</a>), BlackBerry (<a href="http://ekkes-apps.org/">Ekke is working on a updated version, AFAIK</a>), and all other smart phones that feature a browser.</p>

<p>All apps allow you to browse the program, select your favorite talks and get to know the speakers (with headshots so you recognise them in the hallways). We also have included maps of the convention center as well as Santa Clara.</p>

<p>For a first glimpse, watch our video:</p>

<p><div class="embed-video-container"><iframe src="http://player.vimeo.com/video/20377509 "></iframe></div></p>

<p>As of today, both iPhone and Android users can download the apps from the Apple App Store respectively the Android Marketplace. Here are the links:</p>

<ol>
<li> <a href="http://bit.ly/econ2011iphone">EclipseCon 2011 iPhone App</a></li>
<li> <a href="http://bit.ly/econ2011android">EclipseCon 2011 Android App</a></li>
</ol>


<p>If you don&rsquo;t own an iPhone or Android, you can always use the HTML-only version of the conference program available at <a href="http://bit.ly/econ2011html">http://bit.ly/econ2011html</a>.</p>

<p>The iPad and BlackBerry apps will be available soon, so stay tuned!</p>

<p>By the way, if <strong>you</strong> run a conference and are interested in having an app like this, <a href="http://mobile.itemis.com">get in touch with us</a>.</p>
]]></content>
  </entry>
  
</feed>
